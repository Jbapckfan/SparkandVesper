// Level1Scene.swift
import SpriteKit
import simd

final class Level1Scene: SKScene {

    // MARK: - Nodes
    private var bgNode: SKSpriteNode!
    private var parallaxBack: SKSpriteNode!
    private var parallaxMid: SKSpriteNode!
    private var platformNodes: [SKSpriteNode] = []
    private var orbNode: SKSpriteNode!
    private var seamNode: SKSpriteNode!
    private var glyphLayer: SKNode!
    private var postFX: SKSpriteNode!

    // MARK: - Shaders (GLSL ES 2.0 for SpriteKit)
    // Painterly gradient + soft brush noise
    private let gradientShader = SKShader(source:
    """
    // uniforms
    uniform float u_time;
    // varyings
    varying vec2 v_tex_coord;

    // hash & value noise (cheap)
    float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123); }
    float noise(vec2 p){
        vec2 i=floor(p), f=fract(p);
        float a=hash(i), b=hash(i+vec2(1.0,0.0));
        float c=hash(i+vec2(0.0,1.0)), d=hash(i+vec2(1.0,1.0));
        vec2 u=f*f*(3.0-2.0*f);
        return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
    }

    void main(){
        vec2 uv = v_tex_coord;               // 0..1
        // vertical warm->cool gradient
        vec3 topCool = vec3(0.08,0.10,0.18);
        vec3 botWarm = vec3(0.22,0.09,0.03);
        float t = smoothstep(0.0,1.0,uv.y);
        vec3 base = mix(botWarm, topCool, t);

        // broad color banding (very subtle)
        float bands = 0.03 * sin(uv.y*12.0 + u_time*0.25);

        // brush-like noise
        float n1 = noise(uv*4.0 + vec2(0.0,u_time*0.05));
        float n2 = noise(uv*32.0 + vec2(u_time*0.1,0.0));
        float brush = n1*0.15 + n2*0.05;

        // final color
        vec3 col = base + bands + brush;
        gl_FragColor = vec4(col, 1.0);
    }
    """)

    // Soft bevel for platforms (rounded-rect SDF + fake lighting + paper noise)
    private let bevelShader = SKShader(source:
    """
    uniform float u_time;
    uniform vec2  u_size;   // node size in pixels
    uniform float u_radius; // corner radius in px
    uniform vec3  u_tint;   // base color

    varying vec2 v_tex_coord;

    float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123); }
    float noise(vec2 p){
        vec2 i=floor(p), f=fract(p);
        float a=hash(i), b=hash(i+vec2(1,0));
        float c=hash(i+vec2(0,1)), d=hash(i+vec2(1,1));
        vec2 u=f*f*(3.0-2.0*f);
        return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
    }

    // rounded-rect SDF in node-local space
    float sdRoundRect(vec2 p, vec2 b, float r){
        vec2 q = abs(p) - b + vec2(r);
        return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;
    }

    void main(){
        // node-local coords: center at (0,0), pixels
        vec2 px = (v_tex_coord - 0.5) * u_size;
        vec2 halfSize = 0.5 * u_size - vec2(1.0);
        float d = sdRoundRect(px, halfSize, u_radius);

        // inside platform
        float inside = smoothstep(1.5, -1.5, d);

        // gradient normal approx from SDF
        float eps = 2.0;
        float dx = sdRoundRect(px+vec2(eps,0.0), halfSize, u_radius) - sdRoundRect(px-vec2(eps,0.0), halfSize, u_radius);
        float dy = sdRoundRect(px+vec2(0.0,eps), halfSize, u_radius) - sdRoundRect(px-vec2(0.0,eps), halfSize, u_radius);
        vec3 N = normalize(vec3(dx, dy, 2.0)); // fake thickness
        // light dir
        vec3 L = normalize(vec3(-0.4, 0.7, 0.6));
        float diff = clamp(dot(N,L), 0.0, 1.0);

        // edge rim (soft highlight)
        float rim = smoothstep(4.0, 0.0, abs(d)) * 0.35;

        // paper noise
        vec2 uv = v_tex_coord;
        float paper = (noise(uv*24.0) * 0.12) + (noise(uv*4.0 + u_time*0.03) * 0.05);

        vec3 base = u_tint;
        vec3 shaded = base * (0.55 + 0.45*diff) + vec3(rim) + vec3(paper);

        // outside: alpha 0
        float alpha = inside;
        gl_FragColor = vec4(shaded, alpha);
    }
    """)

    // Orb glow (radial + pulsing bloom)
    private let orbShader = SKShader(source:
    """
    uniform float u_time;
    uniform vec2  u_size;
    uniform vec3  u_color;

    varying vec2 v_tex_coord;

    void main(){
        vec2 p = (v_tex_coord - 0.5) * u_size;
        float r = length(p);
        float R = min(u_size.x, u_size.y) * 0.36;

        float core = smoothstep(R, R*0.6, r);
        float pulse = 0.25 + 0.25*sin(u_time*2.0);
        float glow = smoothstep(R*1.8, R*0.2, r) * (0.55 + pulse);

        vec3 col = u_color*(1.0 - core) + u_color*glow;
        float alpha = smoothstep(R*2.0, R*0.1, r);
        gl_FragColor = vec4(col, alpha);
    }
    """)

    // Seam shimmer (vertical veil with subtle refraction-like shimmer & tint)
    private let seamShader = SKShader(source:
    """
    uniform float u_time;
    uniform vec2  u_size;
    uniform vec3  u_color;

    varying vec2 v_tex_coord;

    float hash(float n){ return fract(sin(n)*43758.5453); }
    float noise(vec2 x){
        vec2 p = floor(x);
        vec2 f = fract(x);
        f = f*f*(3.0-2.0*f);
        float n = p.x + p.y*57.0;
        float res = mix(mix(hash(n+0.0), hash(n+1.0), f.x),
                        mix(hash(n+57.0), hash(n+58.0), f.x), f.y);
        return res;
    }

    void main(){
        vec2 px = (v_tex_coord - 0.5) * u_size;
        float halfW = u_size.x * 0.5;
        float band = smoothstep(halfW*0.12, 0.0, abs(px.x)); // centered band

        // shimmer lines
        float ripple = 0.15*sin(px.y*0.08 + u_time*1.2) +
                       0.08*sin(px.y*0.23 - u_time*0.8);
        float grain = (noise(v_tex_coord*64.0 + u_time*0.05)-0.5)*0.08;

        float intensity = clamp(band * (0.35 + ripple + grain), 0.0, 0.6);

        vec3 col = mix(vec3(0.0), u_color, intensity);
        gl_FragColor = vec4(col, intensity);
    }
    """)

    // Film grain + vignette post-process
    private let postShader = SKShader(source:
    """
    uniform float u_time;
    varying vec2 v_tex_coord;

    float hash(vec2 p){ return fract(43758.5453 * sin(dot(p, vec2(12.9898,78.233)))); }

    void main(){
        vec2 uv = v_tex_coord;
        // base: pass-through (we draw solid black behind, so this just overlays FX)
        vec3 col = vec3(0.0);

        // grain
        float g = hash(uv*vec2(1024.0, 1024.0) + u_time);
        float grain = (g - 0.5) * 0.08;

        // vignette
        vec2 c = uv - 0.5;
        float v = smoothstep(0.85, 0.2, dot(c,c)*2.2); // soft falloff
        float vignette = mix(1.0, 0.88, v);

        gl_FragColor = vec4(vec3(grain), 0.065) + vec4(vec3(0.0), 1.0 - vignette);
    }
    """)

    // MARK: - Time
    private var startTime: TimeInterval = 0

    // MARK: - Scene
    override func didMove(to view: SKView) {
        backgroundColor = .black
        startTime = 0

        // BACKGROUND
        bgNode = SKSpriteNode(color: .black, size: size)
        bgNode.position = CGPoint(x: size.width/2, y: size.height/2)
        bgNode.shader = gradientShader
        bgNode.shader?.uniforms = [SKUniform(name: "u_time", float: 0)]
        addChild(bgNode)

        // PARALLAX silhouettes (subtle)
        parallaxBack = makeParallaxStrip(height: size.height*0.28, y: size.height*0.28, alpha: 0.35)
        addChild(parallaxBack)
        parallaxMid = makeParallaxStrip(height: size.height*0.18, y: size.height*0.18, alpha: 0.45)
        addChild(parallaxMid)

        // PLATFORMS
        let tints: [SIMD3<Float>] = [
            SIMD3(0.16, 0.17, 0.22),
            SIMD3(0.19, 0.20, 0.26),
            SIMD3(0.22, 0.22, 0.29)
        ]
        let rects: [CGRect] = [
            CGRect(x: size.width*0.14, y: size.height*0.40, width: size.width*0.28, height: 18),
            CGRect(x: size.width*0.46, y: size.height*0.52, width: size.width*0.34, height: 20),
            CGRect(x: size.width*0.20, y: size.height*0.64, width: size.width*0.24, height: 16)
        ]
        for i in 0..<rects.count {
            platformNodes.append(makePlatform(rect: rects[i], tint: tints[i]))
        }
        platformNodes.forEach(addChild)

        // ORB (Vesper)
        orbNode = SKSpriteNode(color: .clear, size: CGSize(width: 82, height: 82))
        orbNode.position = CGPoint(x: size.width*0.30, y: size.height*0.68)
        orbNode.blendMode = .add
        orbNode.shader = orbShader
        orbNode.shader?.uniforms = [
            SKUniform(name: "u_time", float: 0),
            SKUniform(name: "u_size", vectorFloat2: vector_float2(Float(orbNode.size.width), Float(orbNode.size.height))),
            SKUniform(name: "u_color", vectorFloat3: vector_float3(0.85, 0.62, 0.25))
        ]
        addChild(orbNode)

        // SEAM (dimensional veil)
        seamNode = SKSpriteNode(color: .clear, size: CGSize(width: 64, height: size.height*0.82))
        seamNode.position = CGPoint(x: size.width*0.66, y: size.height*0.54)
        seamNode.shader = seamShader
        seamNode.shader?.uniforms = [
            SKUniform(name: "u_time", float: 0),
            SKUniform(name: "u_size", vectorFloat2: vector_float2(Float(seamNode.size.width), Float(seamNode.size.height))),
            SKUniform(name: "u_color", vectorFloat3: vector_float3(0.58, 0.42, 1.0))
        ]
        addChild(seamNode)

        // GLYPH CLUES (subtle)
        glyphLayer = SKNode()
        addChild(glyphLayer)
        addGlyph("why?", at: CGPoint(x: size.width*0.78, y: size.height*0.82), alpha: 0.14, size: 22, italic: true)
        addGlyph("cold...", at: CGPoint(x: size.width*0.58, y: size.height*0.72), alpha: 0.12, size: 18, italic: false)
        addGlyph("MISS", at: CGPoint(x: size.width*0.28, y: size.height*0.86), alpha: 0.10, size: 16, mono: true)
        addGlyph("YOU", at: CGPoint(x: size.width*0.46, y: size.height*0.86), alpha: 0.10, size: 16, mono: true)

        // POST FX (grain + vignette)
        postFX = SKSpriteNode(color: .clear, size: size)
        postFX.position = CGPoint(x: size.width/2, y: size.height/2)
        postFX.zPosition = 999
        postFX.shader = postShader
        postFX.shader?.uniforms = [SKUniform(name: "u_time", float: 0)]
        addChild(postFX)
    }

    // MARK: - Helpers
    private func makeParallaxStrip(height: CGFloat, y: CGFloat, alpha: CGFloat) -> SKSpriteNode {
        let n = SKSpriteNode(color: .black, size: CGSize(width: size.width*1.2, height: height))
        n.anchorPoint = CGPoint(x: 0.5, y: 0.0)
        n.position = CGPoint(x: size.width/2, y: y - height/2)
        n.alpha = alpha
        n.zPosition = 0.5
        // simple soft mask via corner radius look using bevel shader in fill mode
        n.shader = SKShader(source:
        """
        uniform vec2 u_size;
        varying vec2 v_tex_coord;
        // soft hill line
        float hill(vec2 uv){
            float x = uv.x*2.0 - 1.0;
            return 0.55 + 0.1*sin(x*1.8) + 0.06*sin(x*3.7);
        }
        void main(){
            vec2 uv = v_tex_coord;
            float edge = smoothstep(hill(uv), hill(uv)+0.02, uv.y);
            gl_FragColor = vec4(vec3(0.0), edge);
        }
        """)
        n.shader?.uniforms = [SKUniform(name: "u_size", vectorFloat2: vector_float2(Float(n.size.width), Float(n.size.height)))]
        return n
    }

    private func makePlatform(rect: CGRect, tint: SIMD3<Float>) -> SKSpriteNode {
        let node = SKSpriteNode(color: .clear, size: CGSize(width: rect.width, height: rect.height))
        node.position = CGPoint(x: rect.midX, y: rect.midY)
        node.shader = bevelShader
        node.shader?.uniforms = [
            SKUniform(name: "u_time", float: 0),
            SKUniform(name: "u_size", vectorFloat2: vector_float2(Float(rect.width), Float(rect.height))),
            SKUniform(name: "u_radius", float: Float(min(rect.height, 24)/2)),
            SKUniform(name: "u_tint", vectorFloat3: vector_float3(tint.x, tint.y, tint.z))
        ]
        node.zPosition = 0.9
        return node
    }

    private func addGlyph(_ text: String,
                          at pos: CGPoint,
                          alpha: CGFloat,
                          size: CGFloat,
                          italic: Bool = false,
                          mono: Bool = false) {
        let label = SKLabelNode(text: text)
        label.fontName = mono ? "Menlo" : (italic ? "Times-Italic" : "Times")
        label.fontSize = size
        label.fontColor = UIColor(white: 1.0, alpha: alpha)
        label.position = pos
        label.zPosition = 0.8
        label.horizontalAlignmentMode = .center
        glyphLayer.addChild(label)
    }

    // MARK: - Tick
    override func update(_ currentTime: TimeInterval) {
        if startTime == 0 { startTime = currentTime }
        let t = Float(currentTime - startTime)

        // animate time uniforms
        bgNode.shader?.uniformNamed("u_time")?.floatValue = t
        postFX.shader?.uniformNamed("u_time")?.floatValue = t
        orbNode.shader?.uniformNamed("u_time")?.floatValue = t
        seamNode.shader?.uniformNamed("u_time")?.floatValue = t
        platformNodes.forEach { $0.shader?.uniformNamed("u_time")?.floatValue = t }

        // gentle parallax drift
        parallaxBack.position.x = size.width/2 + CGFloat(sin(t*0.12))*12
        parallaxMid.position.x  = size.width/2 + CGFloat(sin(t*0.18))*20

        // seam subtle sway
        seamNode.position.x = size.width*0.66 + CGFloat(sin(t*0.27))*6
    }
}